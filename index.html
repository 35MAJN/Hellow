<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mohammadali Javadinasab | Portfolio</title>
    
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <link rel="shortcut icon" href="favicon.ico">
    <meta name="theme-color" content="#0071e3">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800;900&family=Vazirmatn:wght@100;300;400;700;900&display=swap" rel="stylesheet">
    
    <!-- Three.js for 3D Brain Simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #e0eafc 0%, #cfdef3 100%);
            --glass-bg: linear-gradient(
                                          135deg,
                                          rgba(255,255,255,0.75),
                                          rgba(255,255,255,0.55)
                                        );
            --glass-border: rgba(255, 255, 255, 0.45);
            --text-main: #1d1d1f;
            --text-dim: #424245;
            --accent: #0071e3;
            --pulse-color: #00e5ff;
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            --nav-height: 60px;
        }

        [data-theme="dark"] {
            --bg-gradient: linear-gradient(135deg, #000000 0%, #1c1c1e 100%);
            --glass-bg: linear-gradient(
                                          135deg,
                                          rgba(28,28,30,0.55),
                                          rgba(28,28,30,0.75)
                                        );
            --glass-border: rgba(255, 255, 255, 0.18);
            --text-main: #f5f5f7;
            --text-dim: #86868b;
            --accent: #2997ff;
            --pulse-color: #ff2a6d;
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0; padding: 0;
            box-sizing: border-box;
            transition: background 0.4s ease, color 0.4s ease, border 0.4s ease;
        }

        body {
            background: var(--bg-gradient);
            background-attachment: fixed;
            color: var(--text-main);
            font-family: 'Inter', -apple-system, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* --- FONT FIX FOR PERSIAN --- */
        [lang="fa"] body, [lang="fa"] p, [lang="fa"] h1, [lang="fa"] h2, [lang="fa"] h3, [lang="fa"] span, [lang="fa"] a, [lang="fa"] li, [lang="fa"] strong { 
            font-family: 'Vazirmatn', sans-serif !important; 
        }
        
        .fas, .fa-solid {
            font-family: "Font Awesome 6 Free" !important;
            font-weight: 900 !important;
        }

        .fab, .fa-brands {
            font-family: "Font Awesome 6 Brands" !important;
            font-weight: 400 !important;
        }

        [lang="fa"] h1 { font-weight: 900 !important; letter-spacing: 0; }

        #bg-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* --- NAVIGATION --- */
        nav {
            position: fixed;
            top: 15px; left: 50%;
            transform: translateX(-50%);
            width: fit-content;
            height: var(--nav-height);
            display: flex; align-items: center;
            padding: 0 10px; z-index: 1000;
            border-radius: 30px;
            background: var(--glass-bg);
            backdrop-filter: blur(11px);
            -webkit-backdrop-filter: blur(11px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--card-shadow);
        }

        .nav-links { display: flex; gap: 20px; padding: 0 15px; }
        .nav-links a {
            text-decoration: none;
            color: var(--text-main);
            font-size: 0.85rem;
            font-weight: 600;
            opacity: 0.6;
        }
        .nav-links a:hover { opacity: 1; color: var(--accent); }

        .controls { 
            display: flex; align-items: center; gap: 8px; 
            border-left: 1px solid var(--glass-border); 
            padding-left: 8px; 
        }
        [dir="rtl"] .controls { border-left: none; border-right: 1px solid var(--glass-border); padding-right: 8px; padding-left: 0; }

        .btn-icon {
            background: none; border: none; color: var(--text-main); cursor: pointer;
            font-size: 1.1rem; width: 38px; height: 38px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
        }
        .btn-icon:hover { background: rgba(0, 113, 227, 0.1); color: var(--accent); }

        .glass-card { background: var(--glass-bg);
                     backdrop-filter: blur(8px);
                     -webkit-backdrop-filter: blur(8px);
                     border: 1px solid var(--glass-border);
                     border-radius: 24px; padding: 40px;
                     background: linear-gradient(
                        120deg,
                        rgba(255,255,255,0.15),
                        rgba(255,255,255,0.05)
                    );
                     box-shadow: var(--card-shadow);
                     margin-bottom: 24px;
                     position: relative;
                    }


        /* --- FULLSCREEN HERO SECTION --- */
        #hero { 
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            padding-top: calc(var(--nav-height) + 40px);
        }

        #brain-container {
            width: 100%;
            flex: 1;
            position: relative;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #brain-container:active { cursor: grabbing; }

        #brain-status {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 600;
            background: rgba(0,0,0,0.05);
            padding: 4px 10px;
            border-radius: 12px;
            pointer-events: none;
            z-index: 10;
        }

        /* --- SVG Morph Container --- */
        #svg-morph-wrapper {
            width: 100%;
            max-width: 450px;
            height: 150px;
            margin: 0 auto 10px auto;
            position: relative;
        }
        
        #morph-svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }
        
        .morph-node {
            fill: var(--accent);
            transition: fill 0.5s ease;
        }
        
        .morph-edge {
            stroke: var(--text-dim);
            stroke-width: 1.5;
            opacity: 0.2;
            transition: stroke 0.5s ease, opacity 0.5s ease, stroke-width 0.5s ease;
        }

        .profile-img {
            width: 130px; height: 130px; border-radius: 50%; object-fit: cover;
            margin-bottom: 15px; border: 3px solid var(--accent); padding: 3px;
            position: relative; z-index: 2; background-color: var(--glass-bg);
        }
        h1 { font-size: 2.2rem; font-weight: 800; letter-spacing: -0.02em; margin-bottom: 8px; }
        .subtitle { font-size: 1.1rem; color: var(--accent); font-weight: 600; margin-bottom: 20px; }
        
        .contact-container {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-bottom: 20px;
        }
        .contact-link {
            text-decoration: none; color: var(--text-main); font-size: 0.9rem;
            display: flex; align-items: center; gap: 8px; transition: color 0.2s;
        }
        .contact-link:hover { color: var(--accent); }

        .grid-layout { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px; }
        .card { padding: 30px; }
        .card h3 { font-size: 1.2rem; margin-bottom: 10px; color: var(--accent); }
        .card .date { font-size: 0.8rem; font-weight: 700; color: var(--text-dim); margin-bottom: 8px; display: block; }
        .card ul { margin-left: 18px; font-size: 0.9rem; color: var(--text-dim); }
        [dir="rtl"] .card ul { margin-left: 0; margin-right: 18px; }

        .skills-wrap { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 20px; }
        .skill-badge {
            padding: 6px 14px; border-radius: 20px; background: rgba(0, 113, 227, 0.1);
            font-size: 0.85rem; font-weight: 600; color: var(--accent);
        }

        footer { text-align: center; padding: 50px 0; opacity: 0.5; font-size: 0.8rem; }
        
        @media (max-width: 600px) {
            nav { width: fit-content; max-width: 95%; top: 10px; }
            .nav-links { display: none; }
            h1 { font-size: 1.9rem; }
            .glass-card { padding: 25px; }
            #svg-morph-wrapper { height: 120px; }
        }
    </style>
</head>
<body>

    <!-- Subtle Background Particles -->
    <canvas id="bg-canvas"></canvas>

    <nav>
        <div class="nav-links">
            <a href="#hero" data-t="nav-home">Home</a>
            <a href="#research" data-t="nav-res">Research</a>
            <a href="#education" data-t="nav-edu">Education</a>
            <a href="#projects" data-t="nav-proj">Projects</a>
        </div>
        <div class="controls">
            <button class="btn-icon" id="lang-btn" title="Toggle Language"><i class="fas fa-language"></i></button>
            <button class="btn-icon" id="theme-btn" title="Toggle Theme"><i class="fas fa-moon"></i></button>
        </div>
    </nav>

    <!-- FULLSCREEN HERO SECTION WITH BRAIN -->
    <section id="hero">
        <!-- Dynamic Morphing SVG Logo -->
        <div id="svg-morph-wrapper">
            <svg id="morph-svg" viewBox="0 0 800 200"></svg>
        </div>
        
        <div id="brain-container">
            <div id="brain-status">Initializing Simulation...</div>
        </div>
    </section>

    <!-- PAGE CONTENT -->
    <div class="container">
        
        <!-- PROFILE CARD (Placed right under the fullscreen view) -->
        <div class="glass-card" style="text-align: center; margin-top: 40px;">
            <img src="pic.jpg" alt="Mohammadali Javadinasab" class="profile-img" onerror="this.src='https://via.placeholder.com/130?text=Profile'">
            
            <h1 data-t="hero-name">Mohammadali Javadinasab</h1>
            <p class="subtitle" data-t="hero-sub">AI Researcher | Electrical Engineer | Co-founder of LearnAmuse</p>
            
            <div class="contact-container">
                <a href="mailto:ma.javadinasab@gmail.com" class="contact-link">
                    <i class="fas fa-envelope"></i> ma.javadinasab@gmail.com
                </a>
                <a href="https://linkedin.com/in/35majn" target="_blank" class="contact-link">
                    <i class="fab fa-linkedin"></i> 35majn
                </a>
                <a href="https://github.com/35MAJN" target="_blank" class="contact-link">
                    <i class="fab fa-github"></i> 35MAJN
                </a>
            </div>

            <div style="margin-top: 10px;">
                <a href="https://learnamuse.com" target="_blank" style="color: var(--accent); font-weight: 800; text-decoration: none; font-size: 1rem;">
                    <i class="fas fa-rocket"></i> LEARNAMUSE.COM
                </a>
            </div>
        </div>

        <h2 style="text-align: center; margin: 40px 0 20px;" data-t="edu-title">Education</h2>
        <div class="grid-layout" id="education">
            <div class="glass-card card">
                <span class="date">2019 — 2024</span>
                <h3 data-t="edu-1-h">B.Sc. Electrical Engineering (Telecommunications)</h3>
                <p><strong>Iran University of Science & Technology (IUST)</strong></p>
                <p class="date">GPA: 3.41/4.0</p>
                <p data-t="edu-1-p">Thesis: Simulating brain neural activities using head model & retrieving activities using Deep Learning (EEG Inverse Problem).</p>
            </div>
            <div class="glass-card card">
                <span class="date">2020 — 2024</span>
                <h3 data-t="edu-2-h">B.Sc. Industrial Engineering (Minor)</h3>
                <p><strong>Iran University of Science & Technology (IUST)</strong></p>
                <p class="date">GPA: 3.32/4.0</p>
                <p data-t="edu-2-p">Focus on Decision-Making Analysis, Marketing, and Project Management.</p>
            </div>
        </div>

        <h2 style="text-align: center; margin: 40px 0 20px;" data-t="exp-title">Experience</h2>
        <div id="experience">
            <div class="glass-card card">
                <span class="date" data-t="exp-1-d">2022 — Present</span>
                <h3 data-t="exp-1-h">Research & Teaching Assistant @ IUST</h3>
                <ul data-t="exp-1-l">
                    <li>Specializing in EEG Source Reconstruction Using Deep Learning.</li>
                    <li>TA for Linear Algebra and AI courses.</li>
                </ul>
            </div>
            <div class="glass-card card">
                <span class="date" data-t="exp-2-d">2021 — 2022</span>
                <h3 data-t="exp-2-h">Python Developer & Data Scientist @ LifeWeb</h3>
                <ul data-t="exp-2-l">
                    <li>Backend solutions with Elasticsearch and Flask.</li>
                    <li>Stock prediction with RNNs and NLP.</li>
                </ul>
            </div>
        </div>

        <h2 style="text-align: center; margin: 40px 0 20px;" data-t="proj-title">Featured Projects</h2>
        <div class="grid-layout" id="projects">
            <div class="glass-card card">
                <h3>Syntax Assistant</h3>
                <p data-t="proj-1">Trained a Deep RNN for Persian voice commands (99.59% accuracy). Built with TensorFlow.</p>
            </div>
            <div class="glass-card card">
                <h3>Field & Flux 3D</h3>
                <p data-t="proj-2">3D Electric field plotting using NumPy and Matplotlib.</p>
            </div>
        </div>

        <div class="glass-card" style="text-align: center;">
            <h2 data-t="skills-title">Technical Arsenal</h2>
            <div class="skills-wrap">
                <span class="skill-badge">Python</span> <span class="skill-badge">TensorFlow</span>
                <span class="skill-badge">PyTorch</span> <span class="skill-badge">MATLAB</span>
                <span class="skill-badge">Three.js</span>
                <span class="skill-badge">Flask</span> <span class="skill-badge">Elasticsearch</span>
                <span class="skill-badge">FedML</span> <span class="skill-badge">IoT</span>
            </div>
        </div>

        <footer data-t="footer-text">
            © 2026 Mohammadali Javadinasab | Tehran, Iran
        </footer>
    </div>

    <script>
        /* --- TRANSLATIONS & THEME --- */
        const translations = {
            en: {
                "nav-home": "Home", "nav-res": "Research", "nav-edu": "Education", "nav-proj": "Projects",
                "hero-name": "Mohammadali Javadinasab",
                "hero-sub": "AI Researcher | Electrical Engineer | Co-founder of LearnAmuse",
                "brain-title": "EEG Source Reconstruction",
                "brain-desc": "The interactive 3D simulation running in the main view demonstrates real-time EEG source reconstruction. It visualizes deep neural dipoles popping into existence and mapping their intensity to the surface potentials of the brain.",
                "edu-title": "Education",
                "edu-1-h": "B.Sc. Electrical Engineering (Telecommunications)",
                "edu-1-p": "Thesis: Simulating brain neural activities using head model & retrieving activities using Deep Learning (EEG Inverse Problem).",
                "edu-2-h": "B.Sc. Industrial Engineering (Minor)",
                "edu-2-p": "Focus on Decision-Making Analysis, Marketing, and Project Management.",
                "exp-title": "Experience",
                "exp-1-d": "2022 — Present", "exp-1-h": "Research & Teaching Assistant @ IUST",
                "exp-1-l": "<li>Specializing in EEG Source Reconstruction Using Deep Learning.</li><li>TA for Linear Algebra and AI courses.</li>",
                "exp-2-h": "Python Developer & Data Scientist @ LifeWeb",
                "exp-2-l": "<li>Backend solutions with Elasticsearch and Flask.</li><li>Stock prediction with RNNs and NLP.</li>",
                "proj-title": "Featured Projects",
                "proj-1": "Deep RNN for Persian voice commands (99.59% accuracy). Built with TensorFlow.",
                "proj-2": "3D Electric field plotting using NumPy and Matplotlib.",
                "skills-title": "Technical Arsenal",
                "footer-text": "© 2026 Mohammadali Javadinasab | Tehran, Iran"
            },
            fa: {
                "nav-home": "خانه", "nav-res": "پژوهش‌ها", "nav-edu": "تحصیلات", "nav-proj": "پروژه‌ها",
                "hero-name": "محمدعلی جوادی‌نسب",
                "hero-sub": "پژوهشگر هوش مصنوعی | مهندس برق | هم‌بنیان‌گذار LearnAmuse",
                "brain-title": "بازسازی منبع EEG",
                "brain-desc": "شبیه‌سازی سه‌بعدی تعاملی در نمای اصلی، بازسازی زنده منبع EEG را نمایش می‌دهد. این شبیه‌سازی نگاشت دوقطبی‌های عصبی عمیق را به پتانسیل‌های سطحی مغز در لحظه بصری می‌سازد.",
                "edu-title": "تحصیلات",
                "edu-1-h": "کارشناسی مهندسی برق (مخابرات)",
                "edu-1-p": "پایان‌نامه: شبیه‌سازی فعالیت‌های عصبی مغز و بازیابی با یادگیری عمیق (حل مسئله معکوس EEG).",
                "edu-2-h": "کارشناسی مهندسی صنایع (دوره فرعی)",
                "edu-2-p": "تمرکز بر تحلیل تصمیم‌گیری، بازاریابی و کنترل پروژه.",
                "exp-title": "تجربیات حرفه‌ای",
                "exp-1-d": "۱۴۰۱ — اکنون", "exp-1-h": "دستیار پژوهشی و آموزشی در دانشگاه علم و صنعت",
                "exp-1-l": "<li>متخصص در بازسازی منابع EEG با استفاده از یادگیری عمیق.</li><li>دستیار آموزشی دروس جبر خطی و هوش مصنوعی.</li>",
                "exp-2-h": "توسعه‌دهنده پایتون و دانشمند داده در لایف‌وب",
                "exp-2-l": "<li>توسعه بک‌اند با Elasticsearch و Flask.</li><li>پیش‌بینی بورس با RNN و NLP.</li>",
                "proj-title": "پروژه‌های منتخب",
                "proj-1": "مدل RNN عمیق برای دستورات صوتی فارسی (دقت ۹۹.۵۹٪).",
                "proj-2": "ترسیم میدان‌های الکتریکی سه‌بعدی با NumPy و Matplotlib.",
                "skills-title": "جعبه‌ابزار فنی",
                "footer-text": "© ۲۰۲۶ محمدعلی جوادی‌نسب | تهران، ایران"
            }
        };

        let currentLang = 'en';
        const langBtn = document.getElementById('lang-btn');

        langBtn.addEventListener('click', () => {
            currentLang = currentLang === 'en' ? 'fa' : 'en';
            document.documentElement.lang = currentLang;
            document.documentElement.dir = currentLang === 'fa' ? 'rtl' : 'ltr';
            document.querySelectorAll('[data-t]').forEach(el => {
                const key = el.getAttribute('data-t');
                el.innerHTML = translations[currentLang][key];
            });
        });

        const themeBtn = document.getElementById('theme-btn');
        themeBtn.addEventListener('click', () => {
            const body = document.body;
            const icon = themeBtn.querySelector('i');
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme'); icon.className = 'fas fa-moon';
            } else {
                body.setAttribute('data-theme', 'dark'); icon.className = 'fas fa-sun';
            }
        });

        /* --- 2D BACKGROUND PARTICLES --- */
        const canvasBg = document.getElementById('bg-canvas');
        const ctxBg = canvasBg.getContext('2d');
        let bgParticles = [];
        window.addEventListener('resize', () => { canvasBg.width = window.innerWidth; canvasBg.height = window.innerHeight; });
        canvasBg.width = window.innerWidth; canvasBg.height = window.innerHeight;

        class Particle {
            constructor() {
                this.x = Math.random() * canvasBg.width; this.y = Math.random() * canvasBg.height;
                this.size = Math.random() * 6 + 4; 
                this.speedX = Math.random() * 0.4 - 0.2; this.speedY = Math.random() * 0.4 - 0.2;
            }
            update() {
                this.x += this.speedX; this.y += this.speedY;
                if (this.x > canvasBg.width || this.x < 0) this.speedX *= -1;
                if (this.y > canvasBg.height || this.y < 0) this.speedY *= -1;
            }
            draw() {
                const isDark = document.body.getAttribute('data-theme') === 'dark';
                ctxBg.fillStyle = getComputedStyle(document.body).getPropertyValue('--accent');
                ctxBg.globalAlpha = isDark ? 0.3 : 0.2;
                ctxBg.beginPath(); ctxBg.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctxBg.fill();
            }
        }
        for (let i = 0; i < 60; i++) bgParticles.push(new Particle());
        function animateBg() {
            ctxBg.clearRect(0, 0, canvasBg.width, canvasBg.height);
            bgParticles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateBg);
        }
        animateBg();


        /* --- 1. SVG NEURAL NETWORK MORPHING LOGO --- */
        document.fonts.ready.then(() => {
            const svg = document.getElementById('morph-svg');
            const svgNS = "http://www.w3.org/2000/svg";
            const width = 800;
            const height = 200;
            const textToMorph = "MAJN35"; 
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width; tempCanvas.height = height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = 'white';
            tCtx.font = `900 130px Inter, sans-serif`;
            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';
            tCtx.fillText(textToMorph, width / 2, height / 2);
            
            const imgData = tCtx.getImageData(0, 0, width, height).data;
            let targetPoints = [];
            
            for(let y = 0; y < height; y += 7) { 
                for(let x = 0; x < width; x += 7) {
                    const alpha = imgData[(y * width + x) * 4 + 3];
                    if(alpha > 128) {
                        targetPoints.push({ x: x + (Math.random()*4-2), y: y + (Math.random()*4-2) });
                    }
                }
            }
            
            targetPoints.sort(() => Math.random() - 0.5);
            
            const nodesCount = targetPoints.length;
            const nodes = [];
            const edges = [];
            
            for(let i = 0; i < nodesCount; i++) {
                let circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('r', Math.random() * 2 + 1.5);
                circle.setAttribute('class', 'morph-node');
                svg.appendChild(circle);
                
                nodes.push({
                    el: circle, x: Math.random() * width, y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 1.5, vy: (Math.random() - 0.5) * 1.5,
                    tx: targetPoints[i].x, ty: targetPoints[i].y
                });
            }
            
            const maxEdges = Math.min(250, nodesCount * 1.5);
            for(let i = 0; i < maxEdges; i++) {
                let line = document.createElementNS(svgNS, 'line');
                line.setAttribute('class', 'morph-edge');
                svg.insertBefore(line, svg.firstChild); 
                edges.push({ el: line });
            }

            let phase = 'wander'; 
            let pulseProgress = 0;
            let morphStartTime = 0;

            setTimeout(() => { phase = 'pulse'; }, 2500);
            setTimeout(() => { phase = 'morph'; morphStartTime = performance.now(); }, 4000);

            function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

            function animateMorph(time) {
                for(let i=0; i<nodesCount; i++) {
                    let n = nodes[i];
                    if (phase === 'wander' || phase === 'pulse') {
                        n.x += n.vx; n.y += n.vy;
                        if(n.x < 0 || n.x > width) n.vx *= -1;
                        if(n.y < 0 || n.y > height) n.vy *= -1;
                    } 
                    else if (phase === 'morph' || phase === 'float') {
                        let t = (time - morphStartTime) / 2500; 
                        if (t > 1) { t = 1; if(phase === 'morph') phase = 'float'; }
                        
                        let easeT = easeOutCubic(t);
                        if (phase === 'morph') {
                            n.x = n.x + (n.tx - n.x) * easeT * 0.1;
                            n.y = n.y + (n.ty - n.y) * easeT * 0.1;
                        } else {
                            n.x += Math.sin(time * 0.001 + i) * 0.1;
                            n.y += Math.cos(time * 0.002 + i) * 0.1;
                            n.x += (n.tx - n.x) * 0.05;
                            n.y += (n.ty - n.y) * 0.05;
                        }
                    }
                    n.el.setAttribute('cx', n.x);
                    n.el.setAttribute('cy', n.y);
                }

                const isDark = document.body.getAttribute('data-theme') === 'dark';
                const accentColor = getComputedStyle(document.body).getPropertyValue('--accent').trim();
                const pulseColor = getComputedStyle(document.body).getPropertyValue('--pulse-color').trim();

                let edgeIdx = 0;
                for(let i=0; i<nodesCount && edgeIdx < maxEdges; i+=2) {
                    let minDist = Infinity;
                    let closest = -1;
                    for(let j=0; j<nodesCount; j++) {
                        if (i === j) continue;
                        let dx = nodes[i].x - nodes[j].x;
                        let dy = nodes[i].y - nodes[j].y;
                        let dist = dx*dx + dy*dy;
                        if (dist < minDist) { minDist = dist; closest = j; }
                    }
                    
                    if (closest !== -1 && minDist < 2500) { 
                        let line = edges[edgeIdx].el;
                        line.setAttribute('x1', nodes[i].x);
                        line.setAttribute('y1', nodes[i].y);
                        line.setAttribute('x2', nodes[closest].x);
                        line.setAttribute('y2', nodes[closest].y);
                        line.style.opacity = phase === 'float' ? 0.05 : (1 - minDist/2500);
                        
                        if (phase === 'pulse') {
                            pulseProgress += 0.0001;
                            let flash = (Math.sin(time * 0.01 + i) > 0.8);
                            line.style.stroke = flash ? pulseColor : accentColor;
                            line.style.strokeWidth = flash ? 2.5 : 1.5;
                            line.style.opacity = flash ? 1 : 0.2;
                            nodes[i].el.style.fill = flash ? pulseColor : accentColor;
                        } else if (phase === 'morph') {
                            line.style.stroke = accentColor;
                            nodes[i].el.style.fill = accentColor;
                        }
                        edgeIdx++;
                    }
                }
                
                while(edgeIdx < maxEdges) { edges[edgeIdx].el.style.opacity = 0; edgeIdx++; }
                requestAnimationFrame(animateMorph);
            }
            requestAnimationFrame(animateMorph);
        });


        /* --- 2. 3D EEG SOURCE RECONSTRUCTION (JSON LOADER / PROCEDURAL FALLBACK) --- */
        window.addEventListener('load', async () => {
            const container = document.getElementById('brain-container');
            const statusEl = document.getElementById('brain-status');
            const scene = new THREE.Scene();
            
            // Initial Camera setup
            const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
            
            // Added dynamic camera positioning function 
            function adjustCamera() {
                if(!container.clientWidth || !container.clientHeight) return;
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                
                // If the screen gets narrow (aspect < 1, like mobile), push the camera back
                // using an inversely proportional distance multiplier + padding.
                const distanceMultiplier = aspect < 1 ? (1 / aspect) * 1.2 : 1;
                const safeMultiplier = Math.min(distanceMultiplier, 2.5); // Cap how far it goes back
                
                const baseDist = 25;
                camera.position.set(baseDist * safeMultiplier, 3.7 * safeMultiplier, baseDist * safeMultiplier);
                camera.lookAt(0, 0, 0);
            }
            
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            
            // Initialize renderer sizes and camera position
            adjustCamera(); 
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const circleCanvas = document.createElement('canvas');
            circleCanvas.width = 64; circleCanvas.height = 64;
            const circleCtx = circleCanvas.getContext('2d');
            circleCtx.beginPath();
            circleCtx.arc(32, 32, 30, 0, Math.PI * 2);
            circleCtx.fillStyle = '#ffffff';
            circleCtx.fill();
            const circleTexture = new THREE.CanvasTexture(circleCanvas);

            // Change base color to pure blue (like MAJN35 theme accent)
            const grayMatterColor = new THREE.Color('#0071e3'); 
            
            // Core arrays to hold points logic
            let pointsCount = 0;
            let finalPositions;
            let finalBaseColors; 
            let finalNormals;

            // --- DATA LOADING & FALLBACK LOGIC ---
            try {
                const response = await fetch('graymatter_coords.json');
                if (!response.ok) throw new Error("JSON not found locally");
                const rawPoints = await response.json();
                
                pointsCount = rawPoints.length; 
                finalPositions = new Float32Array(pointsCount * 3);
                finalBaseColors = new Float32Array(pointsCount * 3);
                finalNormals = new Float32Array(pointsCount * 3);

                let min = {x: Infinity, y: Infinity, z: Infinity};
                let max = {x: -Infinity, y: -Infinity, z: -Infinity};
                
                rawPoints.forEach(p => {
                    min.x = Math.min(min.x, p[0]); max.x = Math.max(max.x, p[0]);
                    min.y = Math.min(min.y, p[1]); max.y = Math.max(max.y, p[1]);
                    min.z = Math.min(min.z, p[2]); max.z = Math.max(max.z, p[2]);
                });

                const center = { x: (min.x+max.x)/2, y: (min.y+max.y)/2, z: (min.z+max.z)/2 };
                const maxSize = Math.max(max.x-min.x, max.y-min.y, max.z-min.z);
                const scale = 24.0 / maxSize; 

                for(let i=0; i<pointsCount; i++) {
                    let x = (rawPoints[i][0] - center.x) * scale;
                    let y = (rawPoints[i][1] - center.y) * scale;
                    let z = (rawPoints[i][2] - center.z) * scale;

                    finalPositions[i*3] = x;
                    finalPositions[i*3+1] = y;
                    finalPositions[i*3+2] = z;

                    let ny = (y / 12.0); 
                    let ambient = 0.55 + 0.45 * Math.max(-0.5, Math.min(1.0, ny)); 
                    let c = grayMatterColor.clone().multiplyScalar(ambient);
                    
                    finalBaseColors[i*3] = c.r;
                    finalBaseColors[i*3+1] = c.g;
                    finalBaseColors[i*3+2] = c.b;
                }
                statusEl.innerHTML = `Loaded ${pointsCount} points from JSON`;
                setTimeout(() => statusEl.style.opacity = 0, 3000);

            } catch(e) {
                console.log("JSON Load Failed, using procedural fallback.", e);
                statusEl.innerHTML = `Running Procedural Engine`;
                setTimeout(() => statusEl.style.opacity = 0, 3000);

                // --- PROCEDURAL BRAIN ---
                pointsCount = 6000;
                finalPositions = new Float32Array(pointsCount * 3);
                finalBaseColors = new Float32Array(pointsCount * 3);
                const goldenRatio = (1 + Math.sqrt(5)) / 2;
                
                let pIdx = 0;
                for(let i=0; i<pointsCount; i++) {
                    let t = i / pointsCount;
                    let phi = Math.acos(1 - 2 * t);
                    let theta = 2 * Math.PI * i / goldenRatio;
                    
                    let nx = Math.sin(phi) * Math.cos(theta);
                    let ny = Math.cos(phi);
                    let nz = Math.sin(phi) * Math.sin(theta); 
                    
                    let r = 12;
                    let fissureDepth = ny > -0.2 ? Math.exp(-Math.pow(nx * 6, 2)) * (ny + 0.2) : 0;
                    r -= fissureDepth * 4.0;
                    if (nz > 0) r -= Math.pow(nz, 2) * 2.0;
                    if (nz < -0.4) r += Math.pow(nz + 0.4, 2) * 1.5;
                    let tempLobeL = Math.exp(- (Math.pow(nx + 0.85, 2) + Math.pow(ny + 0.2, 2) + Math.pow(nz, 2)) * 3.5 );
                    let tempLobeR = Math.exp(- (Math.pow(nx - 0.85, 2) + Math.pow(ny + 0.2, 2) + Math.pow(nz, 2)) * 3.5 );
                    r += (tempLobeL + tempLobeR) * 3.0;
                    let f1 = Math.sin(nx*14) * Math.cos(ny*14) + Math.sin(ny*14) * Math.cos(nz*14) + Math.sin(nz*14) * Math.cos(nx*14);
                    r += f1 * 0.35;
                    if (ny < -0.5) r -= Math.pow(Math.abs(ny + 0.5), 2) * 5;

                    let x = r * nx * 0.72; 
                    let y = r * ny * 0.85; 
                    let z = r * nz * 1.15; 

                    finalPositions[pIdx] = x;
                    finalPositions[pIdx+1] = y;
                    finalPositions[pIdx+2] = z;
                    
                    let ambient = 0.6 + 0.4 * ny; 
                    let creaseShadow = (f1 * 0.05); 
                    let c = grayMatterColor.clone().multiplyScalar(ambient - creaseShadow);
                    
                    finalBaseColors[pIdx] = c.r; finalBaseColors[pIdx+1] = c.g; finalBaseColors[pIdx+2] = c.b;
                    pIdx += 3;
                }
            }

            // --- BUILD GEOMETRY ---
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(finalPositions, 3));
            
            const dynamicColors = new Float32Array(finalBaseColors);
            geometry.setAttribute('color', new THREE.BufferAttribute(dynamicColors, 3));

            const material = new THREE.PointsMaterial({
                size: 2.0,
                vertexColors: true,
                transparent: true,
                opacity: 0.2, // Changed to 0.65 as requested
                depthWrite: false, // Prevents artifacting on overlapping transparent particles
                map: circleTexture
            });

            const brainMesh = new THREE.Points(geometry, material);
            // Correct Anatomical Rotation - upright, no -Math.PI / 2 pitch
            brainMesh.rotation.set(0, THREE.MathUtils.degToRad(90), 0); 
            scene.add(brainMesh);

            // --- SUDDEN HEAT SOURCES LOGIC ---
            const maxSources = 5;
            const activeSources = Array.from({length: maxSources}, () => ({active: false, x: 0, y: 0, z: 0, life: 0}));

            brainMesh.rotation.x = -Math.PI / 2;
            brainMesh.rotation.y = 0;
            brainMesh.rotation.z = 0;
            
            // Moved listener to window to interact regardless of hero content overlap
            const onMove = (e) => {
                let clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let clientY = e.touches ? e.touches[0].clientY : e.clientY;
                let mx = (clientX / window.innerWidth) * 2 - 1;
                let my = -(clientY / window.innerHeight) * 2 + 1;
            };

            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, {passive: true});

            // Adjust the camera automatically whenever the user resizes the window/changes orientation
            window.addEventListener('resize', () => {
                adjustCamera();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            let time = 0;
            const colorAttr = geometry.attributes.color;
            
            // Neon cyan / white bursts for the EEG points
            const hotRGB1 = new THREE.Color(0x00e5ff); 
            const hotRGB2 = new THREE.Color(0x68b684); 

            function animate3D() {
                requestAnimationFrame(animate3D);
                time += 0.015;

                // Smooth rotation + slight auto-pan
                brainMesh.rotation.z += (time * 1 - brainMesh.rotation.z) * 0.2;
                
                // Manage suddenly appearing and disappearing sources
                activeSources.forEach(s => {
                    if (!s.active) {
                        // Small chance to pop in each frame
                        if (Math.random() < 0.02) { 
                            s.active = true;
                            s.life = 1.0;
                            // Pick a random vertex for the source
                            let vIdx = Math.floor(Math.random() * pointsCount) * 3;
                            s.x = finalPositions[vIdx];
                            s.y = finalPositions[vIdx+1]; 
                            s.z = finalPositions[vIdx+2];
                        }
                    } else {
                        // Decay life causing it to disappear
                        s.life -= 0.015; 
                        if (s.life <= 0) s.active = false;
                    }
                });

                // Update surface vertex colors based on active sources
                for(let i = 0; i < pointsCount; i++) {
                    let vx = finalPositions[i*3];
                    let vy = finalPositions[i*3+1];
                    let vz = finalPositions[i*3+2];
                    
                    let totalIntensity = 0;
                    
                    for(let j=0; j<maxSources; j++) {
                        let s = activeSources[j];
                        if(s.active) {
                            let dx = vx - s.x;
                            let dy = vy - s.y;
                            let dz = vz - s.z;
                            let distSq = dx*dx + dy*dy + dz*dz;
                            
                            // Base radius of effect
                            let intensity = Math.max(0, 1.0 - Math.sqrt(distSq) / 7.0);
                            
                            // Make it "pop" in and out based on its life
                            let popMultiplier = s.life > 0.8 ? (1.0 - s.life)/0.2 : (s.life < 0.2 ? s.life/0.2 : 1.0);
                            
                            totalIntensity += Math.pow(intensity * popMultiplier, 2.5); 
                        }
                    }
                    
                    totalIntensity = Math.min(1.0, totalIntensity);

                    // Revert to original shaded color
                    let baseR = finalBaseColors[i*3];
                    let baseG = finalBaseColors[i*3+1];
                    let baseB = finalBaseColors[i*3+2];
                    
                    let r = baseR; let g = baseG; let b = baseB;
                    
                    if (totalIntensity > 0.02) {
                        let targetHot = (totalIntensity > 0.5) ? hotRGB2 : hotRGB1;
                        let lerpFactor = totalIntensity * 2.0;
                        if(lerpFactor > 1) lerpFactor = 1;
                        
                        r = baseR + (targetHot.r - baseR) * lerpFactor;
                        g = baseG + (targetHot.g - baseG) * lerpFactor;
                        b = baseB + (targetHot.b - baseB) * lerpFactor;
                    }

                    colorAttr.setXYZ(i, r, g, b);
                }
                
                colorAttr.needsUpdate = true;
                renderer.render(scene, camera);
            }
            
            animate3D();
        });
    </script>
</body>
</html>
